<!DOCTYPE html>
<html lang="es">

<head>
  <meta charset="utf-8">
  <title>Topologías de Grothendieck y descenso | Cuaderno de Bitácora</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Cardo:ital,wght@0,400;0,700;1,400&family=Google+Sans+Code:ital,wght@0,300..800;1,300..800&family=Libre+Baskerville:ital,wght@0,400;0,700;1,400&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons">
  <!--<link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Rounded:opsz,wght,FILL,GRAD@24,400,0,0&icon_names=routine" />-->
  <link rel="stylesheet" href="http://localhost/style.css"> <!-- Importante porque depende de la dirección donde se sirve -->
  <script>
    MathJax = {
      tex: {
        inlineMath: {'[+]': [['$', '$']]}
      },
      svg: {
        fontCache: 'global'
      },
      output: {
        font: 'mathjax-stix2'
      }
    };
    </script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@4/tex-mml-chtml.js"></script>
</head>

<body>

<script>
  const LOCAL_STORAGE_KEY_THEME = 'theme';

  const THEME_VALUE_AUTO  = 'auto';
  const THEME_VALUE_DARK  = 'dark';
  const THEME_VALUE_LIGHT = 'light';

  const THEME_CLASS_DARK            = 'dark';           // activates dark mode styling
  const THEME_CLASS_DARK_OVERRIDE   = 'dark_override';  // slides toggle to dark mode
  const THEME_CLASS_LIGHT           = 'light';          // here for consistency, but has no real effect
  const THEME_CLASS_LIGHT_OVERRIDE  = 'light_override'; // slides toggle to light mode

  const THEME_CLASS_ALL = Object.freeze([
      THEME_CLASS_DARK,
      THEME_CLASS_DARK_OVERRIDE,
      THEME_CLASS_LIGHT,
      THEME_CLASS_LIGHT_OVERRIDE,
  ])

  function setDocumentClasses(...classes) {
      THEME_CLASS_ALL.forEach((themeClass) => {
          if (classes.includes(themeClass)) {
              document.documentElement.classList.add(themeClass)
          } else {
              document.documentElement.classList.remove(themeClass)
          }
      })
  }

  function setThemeFromLocalStorageOrMediaPreference() {
    console.log("hola")

    const theme = localStorage.getItem(LOCAL_STORAGE_KEY_THEME) || THEME_VALUE_AUTO

    switch (theme) {
        case THEME_VALUE_AUTO:
            if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
                setDocumentClasses(THEME_CLASS_DARK)
            } else if (window.matchMedia('(prefers-color-scheme: light)').matches) {
                setDocumentClasses(THEME_CLASS_LIGHT)
            }
            break

        case THEME_VALUE_DARK:
            setDocumentClasses(THEME_CLASS_DARK, THEME_CLASS_DARK_OVERRIDE)
            break

        case THEME_VALUE_LIGHT:
            setDocumentClasses(THEME_CLASS_LIGHT, THEME_CLASS_LIGHT_OVERRIDE)
            break
    }

    console.log(`theme is: ${theme}`)
  }

  function incrementTheme() {
    const theme = localStorage.getItem(LOCAL_STORAGE_KEY_THEME) || THEME_VALUE_AUTO

    switch (theme) {
        case THEME_VALUE_AUTO:
            localStorage.setItem(LOCAL_STORAGE_KEY_THEME, THEME_VALUE_DARK)
            break

        case THEME_VALUE_DARK:
            localStorage.setItem(LOCAL_STORAGE_KEY_THEME, THEME_VALUE_LIGHT)
            break

        case THEME_VALUE_LIGHT:
            localStorage.removeItem(LOCAL_STORAGE_KEY_THEME)
            break
    }

    setThemeFromLocalStorageOrMediaPreference()
    changeButtonText()
  }

  // Listen for local storage changes on our theme key. This lets
  // one tab to be notified if the theme is changed in another,
  // and update itself accordingly.
  window.addEventListener("storage", (e) => {
      if (e.key == LOCAL_STORAGE_KEY_THEME) {
          setThemeFromLocalStorageOrMediaPreference()
      }
  })

  // Watch for OS-level changes in preference for light/dark mode.
  // This will trigger for example if a user explicitly changes
  // their OS-level light/dark configuration, or on sunrise/sunset
  // if they have it set to automatic.
  window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', e => {
      setThemeFromLocalStorageOrMediaPreference()
  })

  setThemeFromLocalStorageOrMediaPreference()
</script>

<div class="floating_container"><div>Tema:<a id="themeButton" class="nav_link" onclick="incrementTheme()"></a></div> <a class="nav_link" href="http://localhost/./..">Archivo</a></div>

<main>
  <div class="container">
    <h1 class="title_blog">Topologías de Grothendieck y descenso</h1>
    <p class="subtitle_blog">Escrito el 14 de September de 2025. Tiempo de lectura: 4 min.</p>
    <p>El objetivo de estas notas es reflejar las nociones básicas y elementales de topologías de Grothendieck y teoría de descenso de manera informal e intuitiva. Las principales referencias a seguir son las notas de Halpern-Leistner, la sección de Vistoli de <em>FGA Explained</em>, y las notas de ...</p>
<h2 id="prehaces-de-forma-general">Prehaces de forma general</h2>
<p>Un prehaz en un espacio topológico \( (X, \mathcal{T}) \) es simplemente una asignación de un objeto matemático (como espacio vectorial, módulo, representación, etc.) a cada abierto \( U \in \operatorname{Op}(X) \) de manera que los morfismos de inclusión \( i \colon V \to U \) inducen morfismos de restricción. De manera más general, si entendemos el sistema \( \operatorname{Op} X \) de abiertos como una categoría, un prehaz no es más que un funtor contravariante \( \mathcal{F} \colon (\operatorname{Op} X)^\text{op} \to \mathcal{C} \) para alguna categoría de llegada \( \mathcal{C} \).</p>
<p class="definition">Dadas dos categorías \( \mathcal{C} \) y \( \mathcal{D} \), un <i>prehaz</i> en \( \mathcal{C} \) con valores en \( \mathcal{D} \) es un funtor contravariante de \( \mathcal{C} \) a \( \mathcal{D} \).</p>
<p>Dado que los funtores contravariantes tienen su importancia propia dentro de la teoría de categorías, es natural preguntarse por qué es necesario dotarles de un nombre diferente. El objetivo de esta sección es mostrar que, si uno está dispuesto a tomar seriamente la analogía entre prehaces y funciones en un espacio topológico, podemos llegar a afirmaciones interesantes sobre la estructura de los prehaces.</p>
<p>Existe un modelo de prehaz distinguido que formará la base del resto de la disertación. Para el caso de nuestra categoría modelo, \( \operatorname{Op} X \), el conjunto de objetos tiene de forma natural unos mapas de inclusión \( i \colon U \to X \) de forma canónica. En otras palabras, los objetos de la categoría quedan completamente identificados con dichos mapas de inclusión. Una forma de reescribir estas condiciones es mediante un isomorfismo de categorías \( \operatorname{Op} X \simeq \operatorname{Hom}(\cdot, X) = \mathrm{h}_X \). En esta circunstancia concreta, basta con dar la imagen de nuestro funtor en el espacio total \(X\): efectivamente, el resto de imágenes se obtienen por naturalidad simplemente restringiendo el dominio. Este resultado es la esencia del conocido como <em>lema de Yoneda</em>.</p>
<p class="lemma">Dado un prehaz $ \mathcal{F} \colon \mathcal{C}^\text{op} \to \operatorname{Set} $, existe una correspondencia ....</p>
<p>La demostración en el caso de ..... $X = 0$.
\[
\int_{\Omega} \mathrm{d} \omega = \int_{\partial \Omega} \omega.
\]</p>
<h2 id="referencias">Referencias</h2>
<div class="csl-bib-body" style="line-height: 1.35; margin-left: 2em; text-indent:-2em;">
  <div class="csl-entry" style="margin-bottom: 1em;">Goldberg, Samuel I. 1998. <i>Curvature and Homology</i>. 1. publ., Unabridged, corr.enl. Republ. of the 2. print. 1970. Dover Books on Mathematics. Dover Publ.</div>
  <span class="Z3988" title="url_ver=Z39.88-2004&amp;ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fzotero.org%3A2&amp;rft_id=urn%3Aisbn%3A978-0-486-40207-9&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=book&amp;rft.btitle=Curvature%20and%20homology&amp;rft.place=Mineola%2C%20NY&amp;rft.publisher=Dover%20Publ&amp;rft.edition=1.%20publ.%2C%20unabridged%2C%20corr.%2C%20and%20enl.%20republ.%20of%20the%202.%20print.%201970&amp;rft.series=Dover%20books%20on%20mathematics&amp;rft.aufirst=Samuel%20I.&amp;rft.aulast=Goldberg&amp;rft.au=Samuel%20I.%20Goldberg&amp;rft.date=1998&amp;rft.tpages=395&amp;rft.isbn=978-0-486-40207-9&amp;rft.language=eng"></span>
  <div class="csl-entry">Wall, C. T. C. 1993. <i>A geometric introduction to topology</i>. Dover Publications.</div>
  <span class="Z3988" title="url_ver=Z39.88-2004&amp;ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fzotero.org%3A2&amp;rft_id=urn%3Aisbn%3A978-0-486-67850-4&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=book&amp;rft.btitle=A%20geometric%20introduction%20to%20topology&amp;rft.place=New%20York&amp;rft.publisher=Dover%20Publications&amp;rft.aufirst=C.%20T.%20C.&amp;rft.aulast=Wall&amp;rft.au=C.%20T.%20C.%20Wall&amp;rft.date=1993&amp;rft.tpages=168&amp;rft.isbn=978-0-486-67850-4"></span>
</div>
  </div>
</main>

<script>

  const button = document.getElementById("themeButton");

  button.innerText = "Ejemplo"

  function changeButtonText() {
    const theme = localStorage.getItem(LOCAL_STORAGE_KEY_THEME) || THEME_VALUE_AUTO

    const button = document.getElementById("themeButton");
    
    switch (theme) {
      case THEME_VALUE_AUTO:
        button.innerText = "Sistema"
        break

      case THEME_VALUE_DARK:
        button.innerText = "Oscuro"
        break

      case THEME_VALUE_LIGHT:
        button.innerText = "Claro"
        break
    }


  }

  window.addEventListener("storage", (event) => {
        if (event.key == LOCAL_STORAGE_KEY_THEME) {
          changeButtonText()
        }
    })

    changeButtonText()
</script>

<!--<footer>
  <div class="footer_container">
    <div>
      Copyright Pablo Nicolás 2025
    </div>
    <div>
      Built using <a href="https://www.getzola.org/documentation/content/sass/">Zola</a>.
    </div>
  </div>
</footer>-->

</body>

</html>